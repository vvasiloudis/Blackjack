# Blackjack
First, we use the appropriate python libraries that will help us face and solve our specific problem. In the continuation of our code, we meet a class called Deck, where the main function of this class is to play random cards that the player and the dealer will choose, and then we will test how many times this class will play the random cards as each number of the card (e.g. the ace) is found 4 times in the deck. Then we have the SumCards function where the main function of this function is to help us get the sums of the cards by checking whether to use the ace as 11 or not and then doing the appropriate tests. Below in our code, we find the state class where we declare and return the current sum of the dealer's up card and the ace available for use. The next class named Action is declared and set with 1 when the player asks for other cards and with 2 when the player wants to stop. Next, we have the Policy function which includes two functions, init and pi where one returns errors and the other returns the value 3.141592653589793. We also come across a class named Policy1 which prints the status error policy and returns the appropriate status, i.e. if the player continues or stops when the current total exceeds 20. Then we have the class named BlackjackEnv where the initialization is done of the players' and dealer's cards, printing appropriate messages for their cards. It also contains a condition that checks if the player has lost to the dealer, if he has won, or if the game continues. In addition, within this class there is also the step function, which implements a condition that checks if the dealer stops when it reaches >= 17 and hits otherwise, if the dealer loses, otherwise then the final amount of both is compared. Then, through this function, the player draws a card and the appropriate check is made with the dealer's card and we check whether the player has lost or not. Finally, inside this class we find a last function that prints all the information about the cards of the players and the dealer. Then, we have the simulate function, where through this function we will study the behavior of the policy we have implemented. In this function, we store in the game variable the observations we will have from the policy we have implemented and the moves we have made. In the continuation of our code, we will test the policy we have implemented and the results it will print will show us the first two cards that the dealer and the player will have in their possession, the parameters set by the utterance and the moves that are made in each game depending on the cards the players have, as well as the final cards the players have drawn. Next, we'll create one more function in which we'll visualize the data we've collected and draw the appropriate charts. Additionally, we have a class named MCPolicy, where in this class the agent's exploration of whether the player should stop or continue is initiated. Also in the function update_q the gradual update of the average is done, as this is necessary because we can get a situation where the PlayerSum can be less than equal to 11, in this particular case we always lose. Then, a random play of the iterations takes place and we now visualize the new data we have collected. Finally, we print the actions in order to identify any errors.
